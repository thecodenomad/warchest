package main

import (
	"flag"
	"fmt"
	"github.com/gin-contrib/static"
	"github.com/gin-gonic/gin"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
	"warchest/src/auth"
	"warchest/src/config"
	"warchest/src/query"
)

// FailedLoadConfigRC Return code for failing to load the Warchest configuration
const FailedLoadConfigRC = 2

// FailedRetrievingData Return code for failing the retrieval of coin data
const FailedRetrievingData = 3

// FailedCalculatingWallet Return code for failing calculation of wallet
const FailedCalculatingWallet = 4

//
// Env Variables
////////////////////

// CbAPIKey is the api key established via your coinbase profile
const CbAPIKey = "CB_API_KEY"

// CbAPISecret is the secret associated with the cbAPIKey
const CbAPISecret = "CB_API_SECRET"

// DemoConfig is the internal config that is used for demoing
const DemoConfig = "./src/config/testdata/CoinConfig.json"

// LogFile is the location of the logfile generated by a run
const LogFile = "./warchest.log"

// WarchestStaticPath is the env var that defines where public/static files are being served from
const WarchestStaticPath = "WARCHEST_STATIC_PATH"

// WarchestConfigEnv is the environment variable that will point to coin transactions used by Warchest
const WarchestConfigEnv = "WARCHEST_CONFIG"

var (
	once           sync.Once
	warchestWallet *query.Wallet
)

// IsDemoMode is a helper method to determine if CbAPIKey is set to demo (case insensitive)
func IsDemoMode() bool {
	apiKey, ok := os.LookupEnv(CbAPIKey)
	if ok {
		apiKey = strings.ToLower(apiKey)
		demoMode := (apiKey == "demo")
		return demoMode
	}
	return false
}

// GetWalletSingleton will retrieve the wallet singleton used by the application
// TODO: this should take in a new flag to specify whether or not to use local config for the transaction
//       base
func GetWalletSingleton() *query.Wallet {

	// TODO: Could this be a singleton?
	client := http.Client{
		Timeout: time.Second * 10,
	}
	var absClient query.HTTPClient
	absClient = &client
	apiKey := os.Getenv(CbAPIKey)
	apiSecret := os.Getenv(CbAPISecret)
	demoMode := IsDemoMode()
	cbAuth := auth.CBAuth{apiKey, apiSecret}

	// Instantiate the object since it doesn't exist
	once.Do(func() {
		log.Printf("Wallet is being instantiated now")

		// Initialize the singleton object
		warchestWallet = &query.Wallet{Coins: map[string]query.WarchestCoin{}, NetProfit: 0.0}

		// Query Coinbase to build a Warchest Wallet
		if !demoMode {
			// Retreive coins for account
			coins, err := query.GetWarchestCoins(cbAuth, absClient, demoMode)
			if err != nil {
				log.Printf("Failed to retrieve Warchest Coins: %s\n", err)
				return
			}

			log.Printf("There are %d coins in this wallet", len(coins))

			warchestWallet.Coins = coins
			// Only use internal transactions to build wallet
		} else {
			demoConfig := config.LocalConfigFile{Filepath: DemoConfig}
			demoConfig.Load()
			demoConfig.ToConfig()

			demoWallet := demoConfig.WarchestConfig.ToWallet()

			// TODO: Bandaid *hack* to update coins, instead the struct needs to be revisited so that copying
			//       between structs is much easier
			for coinSymbol, coin := range demoWallet.Coins {
				coin.Update(cbAuth, absClient, demoMode)
				warchestWallet.Coins[coinSymbol] = coin
			}
		}
	})

	warchestWallet.UpdateNetProfit(cbAuth, absClient, demoMode)

	return warchestWallet
}

// GetWallet API Endpoint to retrieve a wallet
func GetWallet(c *gin.Context) {
	warchestWallet := GetWalletSingleton()
	if warchestWallet == nil {
		log.Printf("Warchest wallet must be instantiated at runtime prior to this call!")
		c.IndentedJSON(http.StatusInternalServerError, warchestWallet)
	}

	c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
	c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
	c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

	c.IndentedJSON(http.StatusOK, warchestWallet)
}

func setLogger() {
	// TODO: Consider logrus in the future to get JSON based loggin
	file, err := os.OpenFile(LogFile, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		log.Fatal(err)
	}
	log.SetOutput(file)
}

func main() {

	// Args
	serverPtr := flag.Bool("server", false, "whether or not to start server (default port: 8080)")
	savePtr := flag.Bool("save", true, "whether or not to save a list of transactions")
	transactionTypePtr := flag.String("transaction-type", "all", "the type of coin to parse transactions against")

	// Parse the argument flags
	flag.Parse()

	// Establish logger
	setLogger()

	// Setup Client to use
	client := http.Client{
		Timeout: time.Second * 10,
	}
	var absClient query.HTTPClient
	absClient = &client

	log.Println("Server enabled:", *serverPtr)
	log.Println("Save enabled:", *savePtr)
	log.Println("Transaction type:", *transactionTypePtr)

	// Setup Application specifics
	apiKey, keyOk := os.LookupEnv(CbAPIKey)
	apiSecret, secretOk := os.LookupEnv(CbAPISecret)
	_, configOk := os.LookupEnv(WarchestConfigEnv)
	demoMode := IsDemoMode()
	configOnly := false

	//
	// Handle API and configuration errors
	//////////////////////////////////////
	if !(keyOk && secretOk) {
		log.Printf("API Key or API Secret not provided, using config files")
		configOnly = true
	}

	// Can't do much if a config isn't present and API Key/Secret isn't provided
	if !demoMode && configOnly && !configOk {
		fmt.Printf("Auth credentials not provided, and no config files found. Failing!")
		os.Exit(FailedRetrievingData)
	}

	// Setup server
	if *serverPtr {

		// Establish the static path, defaulting to public folder in current execution path
		// NOTE: this is mostly used for testing/developing locally
		staticPath, ok := os.LookupEnv(WarchestStaticPath)
		if !ok {
			log.Printf("WARCHEST_STATIC_PATH not set, using default ./public for serving static files")
			staticPath = "./public"
		} else {
			log.Printf("WARCHEST_STATIC_PATH is set to: %s", staticPath)
		}

		// Establish the locations that will be re-routed to enable vue-ui
		router := gin.Default()

		// Setup static route for Vue Frontend
		router.Use(static.Serve("/", static.LocalFile(staticPath, true)))

		// Simple API to check if server is working correctly
		router.GET("/api/ping", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"message": "pong",
			})
		})

		// Setup Basic call to retrieve wallet
		router.GET("/api/wallet", GetWallet)

		router.Run()
	} else {
		// Establish auth
		cbAuth := auth.CBAuth{apiKey, apiSecret}

		wallet := GetWalletSingleton()

		// Retrieve all available wallets for the account associated with the provided API Key
		if demoMode {
			fmt.Printf("There are %d Coins in the demo wallet: \n", len(wallet.Coins))
		} else {
			accountsResp, _ := query.CBRetrieveAccounts(cbAuth, absClient)
			fmt.Printf("There are %d Accounts for coins, %d that are supported: \n", len(accountsResp.Accounts), len(wallet.Coins))
		}

		for coinSymbol, coin := range wallet.Coins {
			fmt.Printf("\t%s Net Profit: %.6f\n", coinSymbol, coin.Profit)
		}

		fmt.Printf("Total Net Profit: %.6f\n", wallet.NetProfit)
	}
}

// TODO:
// NOTE: Take in an api key env into the make run for the docker execution, and in the example here specifying
// api-key="none" will result in a demo config being loaded.
